# Test cases automatically generated by Pynguin (https://www.pynguin.eu).
# Please check them before you use them.
import pytest
import docstring_parser.parser as module_0
import docstring_parser.common as module_1
import tokenize as module_2
import inspect as module_3
import re as module_4
import ast as module_5
import token as module_6

@pytest.mark.xfail(strict=True)
def test_case_0():
    str_0 = 'Other Params'
    module_0.compose(str_0, rendering_style=str_0)

@pytest.mark.xfail(strict=True)
def test_case_1():
    none_type_0 = None
    docstring_0 = module_0.parse(none_type_0)
    assert f'{type(docstring_0).__module__}.{type(docstring_0).__qualname__}' == 'docstring_parser.common.Docstring'
    assert docstring_0.short_description is None
    assert docstring_0.long_description is None
    assert docstring_0.blank_after_short_description is False
    assert docstring_0.blank_after_long_description is False
    assert docstring_0.meta == []
    assert docstring_0.style == module_1.DocstringStyle.REST
    docstring_1 = module_0.parse(none_type_0)
    assert docstring_1.style == module_1.DocstringStyle.REST
    none_type_1 = None
    module_0.compose(none_type_1)

def test_case_2():
    str_0 = 'T:$eN,ow5{'
    docstring_0 = module_0.parse(str_0)
    assert f'{type(docstring_0).__module__}.{type(docstring_0).__qualname__}' == 'docstring_parser.common.Docstring'
    assert docstring_0.short_description == 'T:$eN,ow5{'
    assert docstring_0.long_description is None
    assert docstring_0.blank_after_short_description is False
    assert docstring_0.blank_after_long_description is False
    assert docstring_0.meta == []
    assert docstring_0.style == module_1.DocstringStyle.REST

@pytest.mark.xfail(strict=True)
def test_case_3():
    str_0 = 'key'
    module_0.compose(str_0, rendering_style=str_0)

@pytest.mark.xfail(strict=True)
def test_case_4():
    none_type_0 = None
    module_2.untokenize(none_type_0)

@pytest.mark.xfail(strict=True)
def test_case_5():
    none_type_0 = None
    var_0 = module_3.formatannotationrelativeto(none_type_0)
    var_0.visit_Constant(var_0)

@pytest.mark.xfail(strict=True)
def test_case_6():
    none_type_0 = None
    docstring_0 = module_0.parse_from_object(none_type_0)
    assert f'{type(docstring_0).__module__}.{type(docstring_0).__qualname__}' == 'docstring_parser.common.Docstring'
    assert docstring_0.short_description is None
    assert docstring_0.long_description is None
    assert docstring_0.blank_after_short_description is False
    assert docstring_0.blank_after_long_description is False
    assert docstring_0.meta == []
    assert docstring_0.style == module_1.DocstringStyle.REST
    docstring_1 = module_0.parse(none_type_0)
    assert docstring_1.style == module_1.DocstringStyle.REST
    docstring_2 = module_0.parse_from_object(none_type_0)
    assert docstring_2.style == module_1.DocstringStyle.REST
    module_3.getlineno(docstring_1)

@pytest.mark.xfail(strict=True)
def test_case_7():
    none_type_0 = None
    module_0.parse(none_type_0, none_type_0)

@pytest.mark.xfail(strict=True)
def test_case_8():
    none_type_0 = None
    module_4.split(none_type_0, none_type_0, flags=none_type_0)

@pytest.mark.xfail(strict=True)
def test_case_9():
    none_type_0 = None
    module_3.getgeneratorstate(none_type_0)

@pytest.mark.xfail(strict=True)
def test_case_10():
    str_0 = ', optional'
    docstring_0 = module_0.parse_from_object(str_0)
    assert f'{type(docstring_0).__module__}.{type(docstring_0).__qualname__}' == 'docstring_parser.common.Docstring'
    assert docstring_0.short_description == "str(object='') -> str"
    assert docstring_0.long_description == "str(bytes_or_buffer[, encoding[, errors]]) -> str\n\nCreate a new string object from the given object. If encoding or\nerrors is specified, then the object must expose a data buffer\nthat will be decoded using the given encoding and error handler.\nOtherwise, returns the result of object.__str__() (if defined)\nor repr(object).\nencoding defaults to sys.getdefaultencoding().\nerrors defaults to 'strict'."
    assert docstring_0.blank_after_short_description is False
    assert docstring_0.blank_after_long_description is False
    assert docstring_0.meta == []
    assert docstring_0.style == module_1.DocstringStyle.REST
    docstring_1 = module_0.parse(str_0)
    assert docstring_1.style == module_1.DocstringStyle.REST
    list_0 = [docstring_1]
    module_2.group(*list_0)

@pytest.mark.xfail(strict=True)
def test_case_11():
    str_0 = 'MV9>\x0bbP$\tz_LW'
    module_0.parse(str_0, str_0)

def test_case_12():
    none_type_0 = None
    with pytest.raises(TypeError):
        module_5.dump(none_type_0, none_type_0)

@pytest.mark.xfail(strict=True)
def test_case_13():
    none_type_0 = None
    module_3.getcoroutinestate(none_type_0)

@pytest.mark.xfail(strict=True)
def test_case_14():
    none_type_0 = None
    module_5.fix_missing_locations(none_type_0)

@pytest.mark.xfail(strict=True)
def test_case_15():
    none_type_0 = None
    docstring_0 = module_0.parse_from_object(none_type_0)
    assert f'{type(docstring_0).__module__}.{type(docstring_0).__qualname__}' == 'docstring_parser.common.Docstring'
    assert docstring_0.short_description is None
    assert docstring_0.long_description is None
    assert docstring_0.blank_after_short_description is False
    assert docstring_0.blank_after_long_description is False
    assert docstring_0.meta == []
    assert docstring_0.style == module_1.DocstringStyle.REST
    module_6.ISTERMINAL(none_type_0)

@pytest.mark.xfail(strict=True)
def test_case_16():
    str_0 = '?MPuaWU,Vb"VEf"\t@'
    docstring_0 = module_0.parse_from_object(str_0)
    assert f'{type(docstring_0).__module__}.{type(docstring_0).__qualname__}' == 'docstring_parser.common.Docstring'
    assert docstring_0.short_description == "str(object='') -> str"
    assert docstring_0.long_description == "str(bytes_or_buffer[, encoding[, errors]]) -> str\n\nCreate a new string object from the given object. If encoding or\nerrors is specified, then the object must expose a data buffer\nthat will be decoded using the given encoding and error handler.\nOtherwise, returns the result of object.__str__() (if defined)\nor repr(object).\nencoding defaults to sys.getdefaultencoding().\nerrors defaults to 'strict'."
    assert docstring_0.blank_after_short_description is False
    assert docstring_0.blank_after_long_description is False
    assert docstring_0.meta == []
    assert docstring_0.style == module_1.DocstringStyle.REST
    module_0.compose(str_0)

@pytest.mark.xfail(strict=True)
def test_case_17():
    none_type_0 = None
    var_0 = module_3.ismemberdescriptor(none_type_0)
    module_0.compose(none_type_0, var_0, indent=var_0)

@pytest.mark.xfail(strict=True)
def test_case_18():
    str_0 = 'o&[v+='
    str_1 = ''
    docstring_0 = module_0.parse(str_1)
    assert f'{type(docstring_0).__module__}.{type(docstring_0).__qualname__}' == 'docstring_parser.common.Docstring'
    assert docstring_0.short_description is None
    assert docstring_0.long_description is None
    assert docstring_0.blank_after_short_description is False
    assert docstring_0.blank_after_long_description is False
    assert docstring_0.meta == []
    assert docstring_0.style == module_1.DocstringStyle.REST
    docstring_1 = module_0.parse_from_object(str_0)
    assert f'{type(docstring_1).__module__}.{type(docstring_1).__qualname__}' == 'docstring_parser.common.Docstring'
    assert docstring_1.short_description == "str(object='') -> str"
    assert docstring_1.long_description == "str(bytes_or_buffer[, encoding[, errors]]) -> str\n\nCreate a new string object from the given object. If encoding or\nerrors is specified, then the object must expose a data buffer\nthat will be decoded using the given encoding and error handler.\nOtherwise, returns the result of object.__str__() (if defined)\nor repr(object).\nencoding defaults to sys.getdefaultencoding().\nerrors defaults to 'strict'."
    assert docstring_1.blank_after_short_description is False
    assert docstring_1.blank_after_long_description is False
    assert docstring_1.meta == []
    assert docstring_1.style == module_1.DocstringStyle.REST
    none_type_0 = None
    list_0 = [none_type_0, none_type_0, none_type_0]
    module_2.any(*list_0)

@pytest.mark.xfail(strict=True)
def test_case_19():
    str_0 = 'hkos4Q\r1yQs\t\\p\n'
    docstring_0 = module_0.parse(str_0)
    assert f'{type(docstring_0).__module__}.{type(docstring_0).__qualname__}' == 'docstring_parser.common.Docstring'
    assert docstring_0.short_description == 'hkos4Q\r1yQs    \\p'
    assert docstring_0.long_description is None
    assert docstring_0.blank_after_short_description is False
    assert docstring_0.blank_after_long_description is False
    assert docstring_0.meta == []
    assert docstring_0.style == module_1.DocstringStyle.REST
    str_1 = 'kM)M5\x0blG+[jkim\x0b|6RD'
    docstring_1 = module_0.parse(str_1)
    assert docstring_1.style == module_1.DocstringStyle.REST
    docstring_2 = module_0.parse(str_1)
    assert docstring_2.style == module_1.DocstringStyle.REST
    docstring_3 = module_0.parse_from_object(str_0)
    assert f'{type(docstring_3).__module__}.{type(docstring_3).__qualname__}' == 'docstring_parser.common.Docstring'
    assert docstring_3.short_description == "str(object='') -> str"
    assert docstring_3.long_description == "str(bytes_or_buffer[, encoding[, errors]]) -> str\n\nCreate a new string object from the given object. If encoding or\nerrors is specified, then the object must expose a data buffer\nthat will be decoded using the given encoding and error handler.\nOtherwise, returns the result of object.__str__() (if defined)\nor repr(object).\nencoding defaults to sys.getdefaultencoding().\nerrors defaults to 'strict'."
    assert docstring_3.blank_after_short_description is False
    assert docstring_3.blank_after_long_description is False
    assert docstring_3.meta == []
    assert docstring_3.style == module_1.DocstringStyle.REST
    none_type_0 = None
    docstring_4 = module_0.parse_from_object(docstring_1)
    assert docstring_4.style == module_1.DocstringStyle.REST
    docstring_5 = module_0.parse_from_object(none_type_0)
    assert docstring_5.style == module_1.DocstringStyle.REST
    module_0.compose(str_0, indent=str_0)

def test_case_20():
    none_type_0 = None
    with pytest.raises(TypeError):
        module_3.getargs(none_type_0)

@pytest.mark.xfail(strict=True)
def test_case_21():
    none_type_0 = None
    module_2.group(*none_type_0)

@pytest.mark.xfail(strict=True)
def test_case_22():
    none_type_0 = None
    var_0 = module_3.isgenerator(none_type_0)
    var_0.__copy__()

@pytest.mark.xfail(strict=True)
def test_case_23():
    str_0 = '-FRp\t]Ft\x0ceFtcu QpM'
    docstring_0 = module_0.parse_from_object(str_0)
    assert f'{type(docstring_0).__module__}.{type(docstring_0).__qualname__}' == 'docstring_parser.common.Docstring'
    assert docstring_0.short_description == "str(object='') -> str"
    assert docstring_0.long_description == "str(bytes_or_buffer[, encoding[, errors]]) -> str\n\nCreate a new string object from the given object. If encoding or\nerrors is specified, then the object must expose a data buffer\nthat will be decoded using the given encoding and error handler.\nOtherwise, returns the result of object.__str__() (if defined)\nor repr(object).\nencoding defaults to sys.getdefaultencoding().\nerrors defaults to 'strict'."
    assert docstring_0.blank_after_short_description is False
    assert docstring_0.blank_after_long_description is False
    assert docstring_0.meta == []
    assert docstring_0.style == module_1.DocstringStyle.REST
    none_type_0 = None
    docstring_1 = module_0.parse_from_object(none_type_0)
    assert docstring_1.style == module_1.DocstringStyle.REST
    module_0.parse_from_object(none_type_0, none_type_0)

@pytest.mark.xfail(strict=True)
def test_case_24():
    str_0 = 'key'
    var_0 = module_4.template(str_0)
    var_1 = var_0.__str__()
    var_2 = var_1.__getnewargs__()
    var_2.reverse()

@pytest.mark.xfail(strict=True)
def test_case_25():
    none_type_0 = None
    docstring_0 = module_0.parse_from_object(none_type_0)
    assert f'{type(docstring_0).__module__}.{type(docstring_0).__qualname__}' == 'docstring_parser.common.Docstring'
    assert docstring_0.short_description is None
    assert docstring_0.long_description is None
    assert docstring_0.blank_after_short_description is False
    assert docstring_0.blank_after_long_description is False
    assert docstring_0.meta == []
    assert docstring_0.style == module_1.DocstringStyle.REST
    docstring_1 = module_0.parse_from_object(none_type_0)
    assert docstring_1.style == module_1.DocstringStyle.REST
    docstring_2 = module_0.parse_from_object(none_type_0)
    assert docstring_2.style == module_1.DocstringStyle.REST
    docstring_3 = module_0.parse_from_object(none_type_0)
    assert docstring_3.style == module_1.DocstringStyle.REST
    var_0 = module_3.isframe(docstring_0)
    var_0.visit_Assign(none_type_0)

def test_case_26():
    str_0 = ''
    docstring_0 = module_0.parse(str_0)
    assert f'{type(docstring_0).__module__}.{type(docstring_0).__qualname__}' == 'docstring_parser.common.Docstring'
    assert docstring_0.short_description is None
    assert docstring_0.long_description is None
    assert docstring_0.blank_after_short_description is False
    assert docstring_0.blank_after_long_description is False
    assert docstring_0.meta == []
    assert docstring_0.style == module_1.DocstringStyle.REST

@pytest.mark.xfail(strict=True)
def test_case_27():
    none_type_0 = None
    module_0.compose(none_type_0)

def test_case_28():
    none_type_0 = None
    with pytest.raises(TypeError):
        module_3.get_annotations(none_type_0, globals=none_type_0, locals=none_type_0, eval_str=none_type_0)

@pytest.mark.xfail(strict=True)
def test_case_29():
    none_type_0 = None
    docstring_0 = module_0.parse_from_object(none_type_0)
    assert f'{type(docstring_0).__module__}.{type(docstring_0).__qualname__}' == 'docstring_parser.common.Docstring'
    assert docstring_0.short_description is None
    assert docstring_0.long_description is None
    assert docstring_0.blank_after_short_description is False
    assert docstring_0.blank_after_long_description is False
    assert docstring_0.meta == []
    assert docstring_0.style == module_1.DocstringStyle.REST
    none_type_1 = None
    module_0.parse_from_object(none_type_1, none_type_0)

def test_case_30():
    str_0 = '{:h\n| '
    docstring_0 = module_0.parse_from_object(str_0)
    assert f'{type(docstring_0).__module__}.{type(docstring_0).__qualname__}' == 'docstring_parser.common.Docstring'
    assert docstring_0.short_description == "str(object='') -> str"
    assert docstring_0.long_description == "str(bytes_or_buffer[, encoding[, errors]]) -> str\n\nCreate a new string object from the given object. If encoding or\nerrors is specified, then the object must expose a data buffer\nthat will be decoded using the given encoding and error handler.\nOtherwise, returns the result of object.__str__() (if defined)\nor repr(object).\nencoding defaults to sys.getdefaultencoding().\nerrors defaults to 'strict'."
    assert docstring_0.blank_after_short_description is False
    assert docstring_0.blank_after_long_description is False
    assert docstring_0.meta == []
    assert docstring_0.style == module_1.DocstringStyle.REST
    docstring_1 = module_0.parse(str_0)
    assert docstring_1.style == module_1.DocstringStyle.REST

@pytest.mark.xfail(strict=True)
def test_case_31():
    none_type_0 = None
    module_0.parse(none_type_0, none_type_0)

@pytest.mark.xfail(strict=True)
def test_case_32():
    str_0 = 'v4fuO!C_/m@\t'
    module_0.parse(str_0, str_0)

def test_case_33():
    none_type_0 = None
    with pytest.raises(TypeError):
        module_3.getfile(none_type_0)

@pytest.mark.xfail(strict=True)
def test_case_34():
    bytes_0 = b'r;\xba\xb9'
    str_0 = '0s3t'
    docstring_0 = module_0.parse(str_0)
    assert f'{type(docstring_0).__module__}.{type(docstring_0).__qualname__}' == 'docstring_parser.common.Docstring'
    assert docstring_0.short_description == '0s3t'
    assert docstring_0.long_description is None
    assert docstring_0.blank_after_short_description is False
    assert docstring_0.blank_after_long_description is False
    assert docstring_0.meta == []
    assert docstring_0.style == module_1.DocstringStyle.REST
    str_1 = ':'
    docstring_1 = module_0.parse(str_1)
    assert f'{type(docstring_1).__module__}.{type(docstring_1).__qualname__}' == 'docstring_parser.common.Docstring'
    assert docstring_1.short_description == ':'
    assert docstring_1.long_description is None
    assert docstring_1.blank_after_short_description is False
    assert docstring_1.blank_after_long_description is False
    assert docstring_1.meta == []
    assert docstring_1.style == module_1.DocstringStyle.GOOGLE
    str_2 = module_0.compose(docstring_1)
    assert str_2 == ':'
    module_0.compose(bytes_0)

@pytest.mark.xfail(strict=True)
def test_case_35():
    str_0 = 'lesdAJ9;GfKa5:j'
    docstring_0 = module_0.parse(str_0)
    assert f'{type(docstring_0).__module__}.{type(docstring_0).__qualname__}' == 'docstring_parser.common.Docstring'
    assert docstring_0.short_description == 'lesdAJ9;GfKa5:j'
    assert docstring_0.long_description is None
    assert docstring_0.blank_after_short_description is False
    assert docstring_0.blank_after_long_description is False
    assert docstring_0.meta == []
    assert docstring_0.style == module_1.DocstringStyle.REST
    docstring_1 = module_0.parse(str_0)
    assert docstring_1.style == module_1.DocstringStyle.REST
    module_0.compose(str_0, str_0, indent=docstring_1)

@pytest.mark.xfail(strict=True)
def test_case_36():
    none_type_0 = None
    module_3.getlineno(none_type_0)

@pytest.mark.xfail(strict=True)
def test_case_37():
    str_0 = ')'
    docstring_0 = module_0.parse_from_object(str_0)
    assert f'{type(docstring_0).__module__}.{type(docstring_0).__qualname__}' == 'docstring_parser.common.Docstring'
    assert docstring_0.short_description == "str(object='') -> str"
    assert docstring_0.long_description == "str(bytes_or_buffer[, encoding[, errors]]) -> str\n\nCreate a new string object from the given object. If encoding or\nerrors is specified, then the object must expose a data buffer\nthat will be decoded using the given encoding and error handler.\nOtherwise, returns the result of object.__str__() (if defined)\nor repr(object).\nencoding defaults to sys.getdefaultencoding().\nerrors defaults to 'strict'."
    assert docstring_0.blank_after_short_description is False
    assert docstring_0.blank_after_long_description is False
    assert docstring_0.meta == []
    assert docstring_0.style == module_1.DocstringStyle.REST
    docstring_1 = module_0.parse(str_0)
    assert docstring_1.style == module_1.DocstringStyle.REST
    str_1 = 'returns'
    docstring_2 = module_0.parse(str_1)
    assert docstring_2.style == module_1.DocstringStyle.REST
    str_2 = module_0.compose(docstring_1)
    assert str_2 == ')'
    str_3 = 'j#dgsKNV<$p\x0cPo8zSl^D'
    module_0.parse(str_3, str_0)

@pytest.mark.xfail(strict=True)
def test_case_38():
    bytes_0 = b'{\x1cE\xaf\x84\xba\xa3\x05%\xfai\xdb8\xa8\xfe$[\x7f\x07'
    none_type_0 = None
    module_4.match(none_type_0, bytes_0, bytes_0)

@pytest.mark.xfail(strict=True)
def test_case_39():
    none_type_0 = None
    none_type_1 = None
    none_type_2 = None
    var_0 = module_3.ismemberdescriptor(none_type_2)
    var_1 = var_0.__eq__(none_type_1)
    var_1.__len__(none_type_0)

@pytest.mark.xfail(strict=True)
def test_case_40():
    float_0 = 264.52
    module_0.parse(float_0)

@pytest.mark.xfail(strict=True)
def test_case_41():
    none_type_0 = None
    docstring_0 = module_0.parse(none_type_0)
    assert f'{type(docstring_0).__module__}.{type(docstring_0).__qualname__}' == 'docstring_parser.common.Docstring'
    assert docstring_0.short_description is None
    assert docstring_0.long_description is None
    assert docstring_0.blank_after_short_description is False
    assert docstring_0.blank_after_long_description is False
    assert docstring_0.meta == []
    assert docstring_0.style == module_1.DocstringStyle.REST
    str_0 = '7\x0b"wQD '
    module_3.getgeneratorstate(str_0)

@pytest.mark.xfail(strict=True)
def test_case_42():
    none_type_0 = None
    docstring_0 = module_0.parse_from_object(none_type_0)
    assert f'{type(docstring_0).__module__}.{type(docstring_0).__qualname__}' == 'docstring_parser.common.Docstring'
    assert docstring_0.short_description is None
    assert docstring_0.long_description is None
    assert docstring_0.blank_after_short_description is False
    assert docstring_0.blank_after_long_description is False
    assert docstring_0.meta == []
    assert docstring_0.style == module_1.DocstringStyle.REST
    docstring_1 = module_0.parse_from_object(docstring_0)
    assert docstring_1.style == module_1.DocstringStyle.REST
    str_0 = ':'
    docstring_2 = module_0.parse(str_0)
    assert f'{type(docstring_2).__module__}.{type(docstring_2).__qualname__}' == 'docstring_parser.common.Docstring'
    assert docstring_2.short_description == ':'
    assert docstring_2.long_description is None
    assert docstring_2.blank_after_short_description is False
    assert docstring_2.blank_after_long_description is False
    assert docstring_2.meta == []
    assert docstring_2.style == module_1.DocstringStyle.GOOGLE
    docstring_3 = module_0.parse_from_object(none_type_0)
    assert docstring_3.style == module_1.DocstringStyle.REST
    module_0.parse_from_object(docstring_0, none_type_0)

@pytest.mark.xfail(strict=True)
def test_case_43():
    str_0 = ''
    module_5.unparse(str_0)

@pytest.mark.xfail(strict=True)
def test_case_44():
    str_0 = 'Ci-1xK}$\t%PZ<lI?j.'
    none_type_0 = None
    module_0.compose(str_0, rendering_style=none_type_0)

@pytest.mark.xfail(strict=True)
def test_case_45():
    none_type_0 = None
    module_3.getclasstree(none_type_0)

@pytest.mark.xfail(strict=True)
def test_case_46():
    str_0 = 'vsU?ri1'
    var_0 = module_5.walk(str_0)
    var_0.translate()

def test_case_47():
    str_0 = '#jU3<'
    docstring_0 = module_0.parse(str_0)
    assert f'{type(docstring_0).__module__}.{type(docstring_0).__qualname__}' == 'docstring_parser.common.Docstring'
    assert docstring_0.short_description == '#jU3<'
    assert docstring_0.long_description is None
    assert docstring_0.blank_after_short_description is False
    assert docstring_0.blank_after_long_description is False
    assert docstring_0.meta == []
    assert docstring_0.style == module_1.DocstringStyle.REST
    with pytest.raises(TypeError):
        module_3.getgeneratorlocals(str_0)

def test_case_48():
    str_0 = 'p\tjrD8K<E-V'
    docstring_0 = module_0.parse(str_0)
    assert f'{type(docstring_0).__module__}.{type(docstring_0).__qualname__}' == 'docstring_parser.common.Docstring'
    assert docstring_0.short_description == 'p       jrD8K<E-V'
    assert docstring_0.long_description is None
    assert docstring_0.blank_after_short_description is False
    assert docstring_0.blank_after_long_description is False
    assert docstring_0.meta == []
    assert docstring_0.style == module_1.DocstringStyle.REST
    str_1 = 'Expected one or no arguments for a '
    with pytest.raises(TypeError):
        module_3.get_annotations(str_1, globals=str_1)

@pytest.mark.xfail(strict=True)
def test_case_49():
    none_type_0 = None
    docstring_0 = module_0.parse(none_type_0)
    assert f'{type(docstring_0).__module__}.{type(docstring_0).__qualname__}' == 'docstring_parser.common.Docstring'
    assert docstring_0.short_description is None
    assert docstring_0.long_description is None
    assert docstring_0.blank_after_short_description is False
    assert docstring_0.blank_after_long_description is False
    assert docstring_0.meta == []
    assert docstring_0.style == module_1.DocstringStyle.REST
    docstring_1 = module_0.parse_from_object(docstring_0)
    assert f'{type(docstring_1).__module__}.{type(docstring_1).__qualname__}' == 'docstring_parser.common.Docstring'
    assert docstring_1.short_description == 'Docstring object representation.'
    assert docstring_1.long_description is None
    assert docstring_1.blank_after_short_description is False
    assert docstring_1.blank_after_long_description is False
    assert docstring_1.meta == []
    assert docstring_1.style == module_1.DocstringStyle.REST
    var_0 = module_3.getcoroutinelocals(none_type_0)
    module_0.compose(var_0, var_0)