# Test cases automatically generated by Pynguin (https://www.pynguin.eu).
# Please check them before you use them.
import pytest
import enum as module_0
import docstring_parser.parser as module_1
import docstring_parser.common as module_2
import token as module_3
import inspect as module_4
import re as module_5
import tokenize as module_6
import ast as module_7

@pytest.mark.xfail(strict=True)
def test_case_0():
    none_type_0 = None
    module_0.unique(none_type_0)

@pytest.mark.xfail(strict=True)
def test_case_1():
    none_type_0 = None
    str_0 = 'e/t]V\nTS :DMnu]H'
    docstring_0 = module_1.parse(str_0)
    assert f'{type(docstring_0).__module__}.{type(docstring_0).__qualname__}' == 'docstring_parser.common.Docstring'
    assert docstring_0.short_description == 'e/t]V'
    assert docstring_0.long_description == 'TS :DMnu]H'
    assert docstring_0.blank_after_short_description is False
    assert docstring_0.blank_after_long_description is False
    assert docstring_0.meta == []
    assert docstring_0.style == module_2.DocstringStyle.REST
    str_1 = '9'
    docstring_1 = module_1.parse(str_1)
    assert docstring_1.style == module_2.DocstringStyle.REST
    module_1.compose(none_type_0, none_type_0, indent=none_type_0)

@pytest.mark.xfail(strict=True)
def test_case_2():
    none_type_0 = None
    docstring_0 = module_1.parse_from_object(none_type_0)
    assert f'{type(docstring_0).__module__}.{type(docstring_0).__qualname__}' == 'docstring_parser.common.Docstring'
    assert docstring_0.short_description is None
    assert docstring_0.long_description is None
    assert docstring_0.blank_after_short_description is False
    assert docstring_0.blank_after_long_description is False
    assert docstring_0.meta == []
    assert docstring_0.style == module_2.DocstringStyle.REST
    str_0 = 'argument'
    docstring_1 = module_1.parse(str_0)
    assert docstring_1.style == module_2.DocstringStyle.REST
    str_1 = module_1.compose(docstring_0)
    assert str_1 == ''
    module_3.ISNONTERMINAL(docstring_0)

def test_case_3():
    none_type_0 = None
    with pytest.raises(TypeError):
        module_4.getgeneratorlocals(none_type_0)

@pytest.mark.xfail(strict=True)
def test_case_4():
    none_type_0 = None
    module_4.getclasstree(none_type_0)

@pytest.mark.xfail(strict=True)
def test_case_5():
    none_type_0 = None
    none_type_1 = None
    docstring_0 = module_1.parse(none_type_1)
    assert f'{type(docstring_0).__module__}.{type(docstring_0).__qualname__}' == 'docstring_parser.common.Docstring'
    assert docstring_0.short_description is None
    assert docstring_0.long_description is None
    assert docstring_0.blank_after_short_description is False
    assert docstring_0.blank_after_long_description is False
    assert docstring_0.meta == []
    assert docstring_0.style == module_2.DocstringStyle.REST
    var_0 = module_4.isdatadescriptor(none_type_1)
    var_0.count(none_type_0)

def test_case_6():
    none_type_0 = None
    docstring_0 = module_1.parse(none_type_0)
    assert f'{type(docstring_0).__module__}.{type(docstring_0).__qualname__}' == 'docstring_parser.common.Docstring'
    assert docstring_0.short_description is None
    assert docstring_0.long_description is None
    assert docstring_0.blank_after_short_description is False
    assert docstring_0.blank_after_long_description is False
    assert docstring_0.meta == []
    assert docstring_0.style == module_2.DocstringStyle.REST

@pytest.mark.xfail(strict=True)
def test_case_7():
    str_0 = 'v7.07\n\n \rgk*.=);Pg'
    none_type_0 = None
    var_0 = module_4.getcoroutinelocals(none_type_0)
    var_0.extend(str_0)

@pytest.mark.xfail(strict=True)
def test_case_8():
    str_0 = 'H+\x0c<\\7i+\x0c[OaZI>+{'
    module_5.compile(str_0)

@pytest.mark.xfail(strict=True)
def test_case_9():
    var_0 = module_6.group()
    var_0.buffer_writer(var_0)

@pytest.mark.xfail(strict=True)
def test_case_10():
    none_type_0 = None
    var_0 = module_4.unwrap(none_type_0)
    var_0.visit_If(none_type_0)

@pytest.mark.xfail(strict=True)
def test_case_11():
    str_0 = '.*defaults to (.+)'
    set_0 = {str_0, str_0}
    docstring_0 = module_1.parse_from_object(set_0)
    assert f'{type(docstring_0).__module__}.{type(docstring_0).__qualname__}' == 'docstring_parser.common.Docstring'
    assert docstring_0.short_description == 'set() -> new empty set object'
    assert docstring_0.long_description == 'set(iterable) -> new set object\n\nBuild an unordered collection of unique elements.'
    assert docstring_0.blank_after_short_description is False
    assert docstring_0.blank_after_long_description is False
    assert docstring_0.meta == []
    assert docstring_0.style == module_2.DocstringStyle.REST
    none_type_0 = None
    docstring_1 = module_1.parse(str_0)
    assert docstring_1.style == module_2.DocstringStyle.REST
    var_0 = module_7.walk(none_type_0)
    docstring_2 = module_1.parse_from_object(none_type_0)
    assert docstring_2.style == module_2.DocstringStyle.REST
    module_1.compose(var_0)

@pytest.mark.xfail(strict=True)
def test_case_12():
    none_type_0 = None
    var_0 = module_4.getmembers(none_type_0, none_type_0)
    var_1 = var_0.__repr__()
    module_1.compose(var_1, rendering_style=none_type_0)

@pytest.mark.xfail(strict=True)
def test_case_13():
    none_type_0 = None
    module_4.getgeneratorstate(none_type_0)

@pytest.mark.xfail(strict=True)
def test_case_14():
    float_0 = 2458.71336
    module_5.compile(float_0)

def test_case_15():
    str_0 = '+'
    docstring_0 = module_1.parse(str_0)
    assert f'{type(docstring_0).__module__}.{type(docstring_0).__qualname__}' == 'docstring_parser.common.Docstring'
    assert docstring_0.short_description == '+'
    assert docstring_0.long_description is None
    assert docstring_0.blank_after_short_description is False
    assert docstring_0.blank_after_long_description is False
    assert docstring_0.meta == []
    assert docstring_0.style == module_2.DocstringStyle.REST

@pytest.mark.xfail(strict=True)
def test_case_16():
    str_0 = '-W(5\x0c;F9rBum9tx(l6'
    docstring_0 = module_1.parse(str_0)
    assert f'{type(docstring_0).__module__}.{type(docstring_0).__qualname__}' == 'docstring_parser.common.Docstring'
    assert docstring_0.short_description == '-W(5\x0c;F9rBum9tx(l6'
    assert docstring_0.long_description is None
    assert docstring_0.blank_after_short_description is False
    assert docstring_0.blank_after_long_description is False
    assert docstring_0.meta == []
    assert docstring_0.style == module_2.DocstringStyle.REST
    str_1 = 'Z@o@[d\x0cLh#'
    docstring_1 = module_1.parse(str_1)
    assert docstring_1.style == module_2.DocstringStyle.REST
    var_0 = module_6.any()
    var_1 = module_5.sub(var_0, var_0, var_0)
    var_2 = var_0.__iter__()
    var_1.__sub__(var_2)

@pytest.mark.xfail(strict=True)
def test_case_17():
    docstring_0 = module_2.Docstring()
    module_1.compose(docstring_0)

@pytest.mark.xfail(strict=True)
def test_case_18():
    str_0 = 'u\nIc= ~^\n`W\\+S'
    docstring_0 = module_1.parse(str_0)
    assert f'{type(docstring_0).__module__}.{type(docstring_0).__qualname__}' == 'docstring_parser.common.Docstring'
    assert docstring_0.short_description == 'u'
    assert docstring_0.long_description == 'Ic= ~^\n`W\\+S'
    assert docstring_0.blank_after_short_description is False
    assert docstring_0.blank_after_long_description is False
    assert docstring_0.meta == []
    assert docstring_0.style == module_2.DocstringStyle.REST
    none_type_0 = None
    docstring_1 = module_1.parse(none_type_0)
    assert docstring_1.style == module_2.DocstringStyle.REST
    var_0 = module_4.getcomments(docstring_1)
    var_0.__xor__(str_0)

@pytest.mark.xfail(strict=True)
def test_case_19():
    none_type_0 = None
    module_1.compose(none_type_0, none_type_0, none_type_0, none_type_0)

@pytest.mark.xfail(strict=True)
def test_case_20():
    str_0 = ''
    docstring_0 = module_1.parse(str_0)
    assert f'{type(docstring_0).__module__}.{type(docstring_0).__qualname__}' == 'docstring_parser.common.Docstring'
    assert docstring_0.short_description is None
    assert docstring_0.long_description is None
    assert docstring_0.blank_after_short_description is False
    assert docstring_0.blank_after_long_description is False
    assert docstring_0.meta == []
    assert docstring_0.style == module_2.DocstringStyle.REST
    bytes_0 = b'\xd7\x8f'
    module_1.parse(bytes_0)

@pytest.mark.xfail(strict=True)
def test_case_21():
    none_type_0 = None
    module_4.getblock(none_type_0)

@pytest.mark.xfail(strict=True)
def test_case_22():
    none_type_0 = None
    docstring_0 = module_1.parse_from_object(none_type_0)
    assert f'{type(docstring_0).__module__}.{type(docstring_0).__qualname__}' == 'docstring_parser.common.Docstring'
    assert docstring_0.short_description is None
    assert docstring_0.long_description is None
    assert docstring_0.blank_after_short_description is False
    assert docstring_0.blank_after_long_description is False
    assert docstring_0.meta == []
    assert docstring_0.style == module_2.DocstringStyle.REST
    module_4.getblock(docstring_0)

def test_case_23():
    str_0 = ''
    docstring_0 = module_1.parse(str_0)
    assert f'{type(docstring_0).__module__}.{type(docstring_0).__qualname__}' == 'docstring_parser.common.Docstring'
    assert docstring_0.short_description is None
    assert docstring_0.long_description is None
    assert docstring_0.blank_after_short_description is False
    assert docstring_0.blank_after_long_description is False
    assert docstring_0.meta == []
    assert docstring_0.style == module_2.DocstringStyle.REST
    str_1 = '?e%a'
    docstring_1 = module_1.parse_from_object(str_1)
    assert f'{type(docstring_1).__module__}.{type(docstring_1).__qualname__}' == 'docstring_parser.common.Docstring'
    assert docstring_1.short_description == "str(object='') -> str"
    assert docstring_1.long_description == "str(bytes_or_buffer[, encoding[, errors]]) -> str\n\nCreate a new string object from the given object. If encoding or\nerrors is specified, then the object must expose a data buffer\nthat will be decoded using the given encoding and error handler.\nOtherwise, returns the result of object.__str__() (if defined)\nor repr(object).\nencoding defaults to sys.getdefaultencoding().\nerrors defaults to 'strict'."
    assert docstring_1.blank_after_short_description is False
    assert docstring_1.blank_after_long_description is False
    assert docstring_1.meta == []
    assert docstring_1.style == module_2.DocstringStyle.REST
    with pytest.raises(TypeError):
        module_4.getfullargspec(docstring_0)

@pytest.mark.xfail(strict=True)
def test_case_24():
    none_type_0 = None
    var_0 = module_4.getouterframes(none_type_0, none_type_0)
    module_1.compose(var_0, rendering_style=var_0)

@pytest.mark.xfail(strict=True)
def test_case_25():
    none_type_0 = None
    module_1.compose(none_type_0)

@pytest.mark.xfail(strict=True)
def test_case_26():
    none_type_0 = None
    module_4.getlineno(none_type_0)

@pytest.mark.xfail(strict=True)
def test_case_27():
    none_type_0 = None
    module_1.compose(none_type_0, rendering_style=none_type_0)

@pytest.mark.xfail(strict=True)
def test_case_28():
    str_0 = 'T\r<]d% {5'
    module_4.getouterframes(str_0)

@pytest.mark.xfail(strict=True)
def test_case_29():
    none_type_0 = None
    module_4.getsourcefile(none_type_0)

@pytest.mark.xfail(strict=True)
def test_case_30():
    none_type_0 = None
    str_0 = '": "'
    docstring_0 = module_1.parse(str_0)
    assert f'{type(docstring_0).__module__}.{type(docstring_0).__qualname__}' == 'docstring_parser.common.Docstring'
    assert docstring_0.short_description == '": "'
    assert docstring_0.long_description is None
    assert docstring_0.blank_after_short_description is False
    assert docstring_0.blank_after_long_description is False
    assert docstring_0.meta == []
    assert docstring_0.style == module_2.DocstringStyle.REST
    module_1.parse(none_type_0, none_type_0)

@pytest.mark.xfail(strict=True)
def test_case_31():
    none_type_0 = None
    module_5.search(none_type_0, none_type_0)

@pytest.mark.xfail(strict=True)
def test_case_32():
    str_0 = '\x0c(d\tX\r x|s}#Q0'
    var_0 = module_4.ismethoddescriptor(str_0)
    var_1 = var_0.__repr__()
    module_1.parse_from_object(str_0, var_1)

@pytest.mark.xfail(strict=True)
def test_case_33():
    str_0 = '6JyxvmgcPJs7BAK'
    module_1.parse_from_object(str_0, str_0)

@pytest.mark.xfail(strict=True)
def test_case_34():
    var_0 = module_6.any()
    module_1.compose(var_0)

@pytest.mark.xfail(strict=True)
def test_case_35():
    str_0 = 'parameter'
    module_4.findsource(str_0)

@pytest.mark.xfail(strict=True)
def test_case_36():
    str_0 = ']Om<*s5'
    module_1.parse(str_0, str_0)

@pytest.mark.xfail(strict=True)
def test_case_37():
    str_0 = 'h'
    module_4.getinnerframes(str_0)

def test_case_38():
    none_type_0 = None
    with pytest.raises(TypeError):
        module_4.getargs(none_type_0)

@pytest.mark.xfail(strict=True)
def test_case_39():
    none_type_0 = None
    docstring_0 = module_1.parse(none_type_0)
    assert f'{type(docstring_0).__module__}.{type(docstring_0).__qualname__}' == 'docstring_parser.common.Docstring'
    assert docstring_0.short_description is None
    assert docstring_0.long_description is None
    assert docstring_0.blank_after_short_description is False
    assert docstring_0.blank_after_long_description is False
    assert docstring_0.meta == []
    assert docstring_0.style == module_2.DocstringStyle.REST
    var_0 = module_4.isasyncgen(none_type_0)
    var_1 = module_3.ISEOF(var_0)
    var_1.count(none_type_0)

@pytest.mark.xfail(strict=True)
def test_case_40():
    int_0 = 1559
    docstring_0 = module_1.parse_from_object(int_0)
    assert f'{type(docstring_0).__module__}.{type(docstring_0).__qualname__}' == 'docstring_parser.common.Docstring'
    assert docstring_0.short_description == 'int([x]) -> integer'
    assert docstring_0.long_description == "int(x, base=10) -> integer\n\nConvert a number or string to an integer, or return 0 if no arguments\nare given.  If x is a number, return x.__int__().  For floating point\nnumbers, this truncates towards zero.\n\nIf x is not a number or if base is given, then x must be a string,\nbytes, or bytearray instance representing an integer literal in the\ngiven base.  The literal can be preceded by '+' or '-' and be surrounded\nby whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.\nBase 0 means to interpret the base from the string as an integer literal.\n>>> int('0b100', base=0)\n4"
    assert docstring_0.blank_after_short_description is False
    assert docstring_0.blank_after_long_description is False
    assert docstring_0.meta == []
    assert docstring_0.style == module_2.DocstringStyle.REST
    none_type_0 = None
    docstring_1 = module_1.parse_from_object(none_type_0)
    assert docstring_1.style == module_2.DocstringStyle.REST
    docstring_2 = module_1.parse_from_object(none_type_0)
    assert docstring_2.style == module_2.DocstringStyle.REST
    lambda_0 = module_7.Lambda()
    docstring_3 = module_1.parse(none_type_0)
    assert docstring_3.style == module_2.DocstringStyle.REST
    str_0 = 'k:C<"'
    docstring_4 = module_1.parse(str_0)
    assert docstring_4.style == module_2.DocstringStyle.REST
    dict_0 = {str_0: str_0, str_0: str_0, str_0: str_0}
    str_1 = '{'
    docstring_5 = module_1.parse(str_1)
    assert docstring_5.style == module_2.DocstringStyle.REST
    module_1.compose(dict_0)

@pytest.mark.xfail(strict=True)
def test_case_41():
    none_type_0 = None
    module_4.getlineno(none_type_0)

@pytest.mark.xfail(strict=True)
def test_case_42():
    none_type_0 = None
    module_5.fullmatch(none_type_0, none_type_0)

@pytest.mark.xfail(strict=True)
def test_case_43():
    str_0 = 'Xj\r#u\r'
    none_type_0 = None
    module_1.parse(str_0, none_type_0)

@pytest.mark.xfail(strict=True)
def test_case_44():
    str_0 = "MG0@s,n's-awtDyR,"
    module_1.parse(str_0, str_0)

@pytest.mark.xfail(strict=True)
def test_case_45():
    str_0 = '2=+V\x0cD&'
    docstring_0 = module_1.parse(str_0)
    assert f'{type(docstring_0).__module__}.{type(docstring_0).__qualname__}' == 'docstring_parser.common.Docstring'
    assert docstring_0.short_description == '2=+V\x0cD&'
    assert docstring_0.long_description is None
    assert docstring_0.blank_after_short_description is False
    assert docstring_0.blank_after_long_description is False
    assert docstring_0.meta == []
    assert docstring_0.style == module_2.DocstringStyle.REST
    module_1.parse(docstring_0)

@pytest.mark.xfail(strict=True)
def test_case_46():
    none_type_0 = None
    docstring_0 = module_1.parse_from_object(none_type_0)
    assert f'{type(docstring_0).__module__}.{type(docstring_0).__qualname__}' == 'docstring_parser.common.Docstring'
    assert docstring_0.short_description is None
    assert docstring_0.long_description is None
    assert docstring_0.blank_after_short_description is False
    assert docstring_0.blank_after_long_description is False
    assert docstring_0.meta == []
    assert docstring_0.style == module_2.DocstringStyle.REST
    docstring_1 = module_1.parse_from_object(none_type_0)
    assert docstring_1.style == module_2.DocstringStyle.REST
    module_1.compose(none_type_0, indent=docstring_1)

@pytest.mark.xfail(strict=True)
def test_case_47():
    none_type_0 = None
    module_5.escape(none_type_0)

@pytest.mark.xfail(strict=True)
def test_case_48():
    none_type_0 = None
    var_0 = module_4.getinnerframes(none_type_0)
    var_1 = var_0.__repr__()
    var_2 = var_0.__len__()
    var_3 = var_2.__repr__()
    str_0 = 's\\eD;wYT>0!\x0cL'
    module_1.compose(var_2, none_type_0, indent=str_0)

@pytest.mark.xfail(strict=True)
def test_case_49():
    none_type_0 = None
    module_4.classify_class_attrs(none_type_0)