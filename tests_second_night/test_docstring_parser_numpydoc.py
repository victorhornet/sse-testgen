# Test cases automatically generated by Pynguin (https://www.pynguin.eu).
# Please check them before you use them.
import pytest
import inspect as module_0
import docstring_parser.numpydoc as module_1
import ast as module_2
import docstring_parser.common as module_3
import re as module_4
import textwrap as module_5
import tokenize as module_6
import token as module_7

@pytest.mark.xfail(strict=True)
def test_case_0():
    str_0 = 'a)B=<K,o{85['
    module_0.getouterframes(str_0)

@pytest.mark.xfail(strict=True)
def test_case_1():
    numpydoc_parser_0 = module_1.NumpydocParser()
    assert f'{type(numpydoc_parser_0).__module__}.{type(numpydoc_parser_0).__qualname__}' == 'docstring_parser.numpydoc.NumpydocParser'
    assert f'{type(numpydoc_parser_0.sections).__module__}.{type(numpydoc_parser_0.sections).__qualname__}' == 'builtins.dict'
    assert len(numpydoc_parser_0.sections) == 31
    assert f'{type(numpydoc_parser_0.titles_re).__module__}.{type(numpydoc_parser_0.titles_re).__qualname__}' == 're.Pattern'
    var_0 = module_0.ismethoddescriptor(numpydoc_parser_0)
    var_0.__instancecheck__(numpydoc_parser_0, numpydoc_parser_0)

def test_case_2():
    none_type_0 = None
    with pytest.raises(TypeError):
        module_2.dump(none_type_0)

@pytest.mark.xfail(strict=True)
def test_case_3():
    str_0 = ',o|`N"Pvi@_0\n\x0bd\x0cSsm`'
    yields_section_0 = module_1.YieldsSection(str_0, str_0)
    assert module_1.YieldsSection.is_generator is True
    module_0.cleandoc(yields_section_0)

@pytest.mark.xfail(strict=True)
def test_case_4():
    str_0 = "'ZIG)\r(MWFo`u,"
    deprecation_section_0 = module_1.DeprecationSection(str_0, str_0)
    none_type_0 = None
    module_0.getabsfile(none_type_0)

def test_case_5():
    str_0 = '\\\t`(R.\t~jR@'
    deprecation_section_0 = module_1.DeprecationSection(str_0, str_0)
    str_1 = '\tRmpg(K&#y'
    deprecation_section_1 = module_1.DeprecationSection(str_1, str_1)
    none_type_0 = None
    iterable_0 = deprecation_section_1.parse(none_type_0)
    iterable_1 = deprecation_section_1.parse(str_1)
    iterable_2 = deprecation_section_1.parse(deprecation_section_1)
    deprecation_section_2 = module_1.DeprecationSection(str_1, str_1)

@pytest.mark.xfail(strict=True)
def test_case_6():
    str_0 = '-) 5V,@oF:Y#j7'
    module_1.NumpydocParser(str_0)

@pytest.mark.xfail(strict=True)
def test_case_7():
    str_0 = 'w4\n?oAJ\x0c6@GyfLT'
    var_0 = module_0.isasyncgen(str_0)
    var_0.get(str_0)

@pytest.mark.xfail(strict=True)
def test_case_8():
    str_0 = 'Raise'
    str_1 = 'Parse the docstring into its components.\n\n    :param text: docstring text to parse\n    :param style: docstring style\n    :returns: parsed docstring representation\n    '
    docstring_0 = module_1.parse(str_1)
    assert f'{type(docstring_0).__module__}.{type(docstring_0).__qualname__}' == 'docstring_parser.common.Docstring'
    assert docstring_0.short_description == 'Parse the docstring into its components.'
    assert docstring_0.long_description == ':param text: docstring text to parse\n:param style: docstring style\n:returns: parsed docstring representation'
    assert docstring_0.blank_after_short_description is True
    assert docstring_0.blank_after_long_description is False
    assert docstring_0.meta == []
    assert docstring_0.style == module_3.DocstringStyle.NUMPYDOC
    sphinx_section_0 = module_1._SphinxSection(str_0, str_0)
    module_0.getlineno(docstring_0)

@pytest.mark.xfail(strict=True)
def test_case_9():
    numpydoc_parser_0 = module_1.NumpydocParser()
    assert f'{type(numpydoc_parser_0).__module__}.{type(numpydoc_parser_0).__qualname__}' == 'docstring_parser.numpydoc.NumpydocParser'
    assert f'{type(numpydoc_parser_0.sections).__module__}.{type(numpydoc_parser_0.sections).__qualname__}' == 'builtins.dict'
    assert len(numpydoc_parser_0.sections) == 31
    assert f'{type(numpydoc_parser_0.titles_re).__module__}.{type(numpydoc_parser_0.titles_re).__qualname__}' == 're.Pattern'
    var_0 = module_0.getattr_static(numpydoc_parser_0, numpydoc_parser_0, numpydoc_parser_0)
    var_0.visit_ClassDef(var_0)

@pytest.mark.xfail(strict=True)
def test_case_10():
    str_0 = '-'
    none_type_0 = None
    docstring_0 = module_1.parse(none_type_0)
    assert f'{type(docstring_0).__module__}.{type(docstring_0).__qualname__}' == 'docstring_parser.common.Docstring'
    assert docstring_0.short_description is None
    assert docstring_0.long_description is None
    assert docstring_0.blank_after_short_description is False
    assert docstring_0.blank_after_long_description is False
    assert docstring_0.meta == []
    assert docstring_0.style == module_3.DocstringStyle.NUMPYDOC
    str_1 = '^Hw\r!}? !Wl~Jlh}(!n('
    yields_section_0 = module_1.YieldsSection(str_0, str_1)
    assert module_1.YieldsSection.is_generator is True
    module_1.parse(yields_section_0)

@pytest.mark.xfail(strict=True)
def test_case_11():
    str_0 = '.i\n|O9'
    module_2.copy_location(str_0, str_0)

@pytest.mark.xfail(strict=True)
def test_case_12():
    none_type_0 = None
    module_4.split(none_type_0, none_type_0)

@pytest.mark.xfail(strict=True)
def test_case_13():
    str_0 = '%m)kG*S'
    deprecation_section_0 = module_1.DeprecationSection(str_0, str_0)
    module_0.getsourcelines(str_0)

@pytest.mark.xfail(strict=True)
def test_case_14():
    match_mapping_0 = module_2.MatchMapping()
    none_type_0 = None
    module_2.increment_lineno(none_type_0)

@pytest.mark.xfail(strict=True)
def test_case_15():
    none_type_0 = None
    var_0 = module_0.isfunction(none_type_0)
    none_type_1 = None
    module_0.getabsfile(none_type_1, none_type_1)

@pytest.mark.xfail(strict=True)
def test_case_16():
    none_type_0 = None
    module_0.classify_class_attrs(none_type_0)

@pytest.mark.xfail(strict=True)
def test_case_17():
    none_type_0 = None
    var_0 = module_0.isabstract(none_type_0)
    var_0.count(none_type_0)

@pytest.mark.xfail(strict=True)
def test_case_18():
    str_0 = 'deprecation'
    yields_section_0 = module_1.YieldsSection(str_0, str_0)
    assert module_1.YieldsSection.is_generator is True
    iterable_0 = yields_section_0.parse(str_0)
    str_1 = 'nePPWyN_ZR'
    iterable_1 = yields_section_0.parse(str_1)
    numpydoc_parser_0 = module_1.NumpydocParser()
    assert f'{type(numpydoc_parser_0).__module__}.{type(numpydoc_parser_0).__qualname__}' == 'docstring_parser.numpydoc.NumpydocParser'
    assert f'{type(numpydoc_parser_0.sections).__module__}.{type(numpydoc_parser_0.sections).__qualname__}' == 'builtins.dict'
    assert len(numpydoc_parser_0.sections) == 31
    assert f'{type(numpydoc_parser_0.titles_re).__module__}.{type(numpydoc_parser_0.titles_re).__qualname__}' == 're.Pattern'
    none_type_0 = None
    none_type_1 = None
    numpydoc_parser_1 = module_1.NumpydocParser(none_type_0)
    module_5.dedent(none_type_1)

@pytest.mark.xfail(strict=True)
def test_case_19():
    bytes_0 = b"\xd4\xb3\xe0\xf9\xbd\xc6o\xa5\xd1\xf0\x12\xbf\xaf'\x06u\xb7"
    k_v_section_0 = module_1._KVSection(bytes_0, bytes_0)
    module_2.unparse(bytes_0)

@pytest.mark.xfail(strict=True)
def test_case_20():
    str_0 = 'km++[i ~ZJ5s\r!'
    str_1 = 'Zq.k?Q2v5g,.kh='
    param_section_0 = module_1.ParamSection(str_0, str_1)
    returns_section_0 = module_1.ReturnsSection(str_0, str_0)
    str_2 = '3--P\x0b.r4)x((Y@\x0cjKOs\x0b'
    str_3 = 'X#$b'
    yields_section_0 = module_1.YieldsSection(str_2, str_3)
    assert module_1.YieldsSection.is_generator is True
    str_4 = '}^HW/'
    var_0 = module_0.stack()
    var_0.parse(str_4)

@pytest.mark.xfail(strict=True)
def test_case_21():
    str_0 = 'a:4}NP;@%A|'
    str_1 = '\\s*(.+?)\\s*\\(\\s*(.*[^\\s]+)\\s*\\)'
    k_v_section_0 = module_1._KVSection(str_0, str_1)
    iterable_0 = k_v_section_0.parse(str_1)
    module_2.increment_lineno(k_v_section_0)

@pytest.mark.xfail(strict=True)
def test_case_22():
    str_0 = '\t.%VQln2g~u'
    docstring_0 = module_1.parse(str_0)
    assert f'{type(docstring_0).__module__}.{type(docstring_0).__qualname__}' == 'docstring_parser.common.Docstring'
    assert docstring_0.short_description == '.%VQln2g~u'
    assert docstring_0.long_description is None
    assert docstring_0.blank_after_short_description is False
    assert docstring_0.blank_after_long_description is False
    assert docstring_0.meta == []
    assert docstring_0.style == module_3.DocstringStyle.NUMPYDOC
    module_1.compose(str_0)

def test_case_23():
    none_type_0 = None
    with pytest.raises(TypeError):
        module_0.getcallargs(none_type_0)

def test_case_24():
    list_0 = []
    none_type_0 = None
    str_0 = 'W\t-K4'
    param_section_0 = module_1.ParamSection(str_0, str_0)
    yields_section_0 = module_1.YieldsSection(str_0, list_0)
    assert module_1.YieldsSection.is_generator is True
    none_type_1 = None
    str_1 = 'see_also'
    returns_section_0 = module_1.ReturnsSection(str_1, none_type_1)
    var_0 = module_0.trace()
    raises_section_0 = module_1.RaisesSection(none_type_0, list_0)
    iterable_0 = returns_section_0.parse(str_1)

def test_case_25():
    str_0 = 'W!38YeIZXl'
    str_1 = '`:S<nW$S)VNJsn'
    section_0 = module_1.Section(str_0, str_1)
    assert f'{type(module_1.Section.title_pattern).__module__}.{type(module_1.Section.title_pattern).__qualname__}' == 'builtins.property'
    with pytest.raises(AttributeError):
        module_0.getattr_static(str_0, str_0)

@pytest.mark.xfail(strict=True)
def test_case_26():
    str_0 = '>f{fb:gM[\r?+ne`nwBX'
    str_1 = 'Examples'
    section_0 = module_1.Section(str_0, str_1)
    assert f'{type(module_1.Section.title_pattern).__module__}.{type(module_1.Section.title_pattern).__qualname__}' == 'builtins.property'
    str_2 = "Initialize self.\n\n        :param args: list of arguments. The exact content of this variable is\n                     dependent on the kind of docstring; it's used to distinguish between\n                     custom docstring meta information items.\n        :param description: associated docstring description.\n        "
    docstring_0 = module_1.parse(str_2)
    assert f'{type(docstring_0).__module__}.{type(docstring_0).__qualname__}' == 'docstring_parser.common.Docstring'
    assert docstring_0.short_description == 'Initialize self.'
    assert docstring_0.long_description == ":param args: list of arguments. The exact content of this variable is\n             dependent on the kind of docstring; it's used to distinguish between\n             custom docstring meta information items.\n:param description: associated docstring description."
    assert docstring_0.blank_after_short_description is True
    assert docstring_0.blank_after_long_description is False
    assert docstring_0.meta == []
    assert docstring_0.style == module_3.DocstringStyle.NUMPYDOC
    param_section_0 = module_1.ParamSection(str_2, str_2)
    iterable_0 = section_0.parse(str_0)
    module_5.dedent(iterable_0)

@pytest.mark.xfail(strict=True)
def test_case_27():
    none_type_0 = None
    str_0 = '\x0ceFtcu '
    module_1.compose(none_type_0, indent=str_0)

@pytest.mark.xfail(strict=True)
def test_case_28():
    str_0 = '6eNKX<5KKm?'
    str_1 = 'Args'
    str_2 = '/biqCY&G8.\nMb0Q>yR'
    raises_section_0 = module_1.RaisesSection(str_1, str_2)
    str_3 = 'xLnq*{4\\EIiLV('
    var_0 = module_0.formatannotation(str_3, str_0)
    var_1 = var_0.isupper()
    var_1.index(str_0)

def test_case_29():
    str_0 = 'fXe%h"\rK{A'
    returns_section_0 = module_1.ReturnsSection(str_0, str_0)
    with pytest.raises(TypeError):
        module_0.getgeneratorlocals(str_0)

@pytest.mark.xfail(strict=True)
def test_case_30():
    none_type_0 = None
    var_0 = module_6.maybe()
    var_1 = var_0.isidentifier()
    var_1.add_section(none_type_0)

def test_case_31():
    str_0 = 'returns'
    deprecation_section_0 = module_1.DeprecationSection(str_0, str_0)

@pytest.mark.xfail(strict=True)
def test_case_32():
    numpydoc_parser_0 = module_1.NumpydocParser()
    assert f'{type(numpydoc_parser_0).__module__}.{type(numpydoc_parser_0).__qualname__}' == 'docstring_parser.numpydoc.NumpydocParser'
    assert f'{type(numpydoc_parser_0.sections).__module__}.{type(numpydoc_parser_0.sections).__qualname__}' == 'builtins.dict'
    assert len(numpydoc_parser_0.sections) == 31
    assert f'{type(numpydoc_parser_0.titles_re).__module__}.{type(numpydoc_parser_0.titles_re).__qualname__}' == 're.Pattern'
    numpydoc_parser_1 = module_1.NumpydocParser()
    var_0 = module_6.any()
    var_0.get(numpydoc_parser_1, numpydoc_parser_0)

@pytest.mark.xfail(strict=True)
def test_case_33():
    none_type_0 = None
    module_0.cleandoc(none_type_0)

@pytest.mark.xfail(strict=True)
def test_case_34():
    str_0 = ';nT=Sb5$HX]'
    var_0 = module_0.formatannotationrelativeto(str_0)
    var_0.visit_FunctionType(str_0)

@pytest.mark.xfail(strict=True)
def test_case_35():
    str_0 = '8'
    none_type_0 = None
    module_1.compose(str_0, str_0, none_type_0)

def test_case_36():
    none_type_0 = None
    with pytest.raises(TypeError):
        module_0.getfullargspec(none_type_0)

@pytest.mark.xfail(strict=True)
def test_case_37():
    none_type_0 = None
    none_type_1 = None
    var_0 = module_0.ismethod(none_type_1)
    var_0.__iadd__(none_type_0)

@pytest.mark.xfail(strict=True)
def test_case_38():
    str_0 = 'h57gD-T'
    none_type_0 = None
    deprecation_section_0 = module_1.DeprecationSection(none_type_0, str_0)
    examples_section_0 = module_1.ExamplesSection(str_0, str_0)
    var_0 = module_6.maybe()
    var_0.parse(str_0)

@pytest.mark.xfail(strict=True)
def test_case_39():
    str_0 = 'R'
    module_0.getouterframes(str_0)

@pytest.mark.xfail(strict=True)
def test_case_40():
    str_0 = '?H'
    var_0 = module_0.getcomments(str_0)
    var_0.visit_While(str_0)

@pytest.mark.xfail(strict=True)
def test_case_41():
    none_type_0 = None
    str_0 = '`?o|L+[?$:kRjETM3:v9'
    yields_section_0 = module_1.YieldsSection(str_0, str_0)
    assert module_1.YieldsSection.is_generator is True
    module_0.getmro(none_type_0)

@pytest.mark.xfail(strict=True)
def test_case_42():
    none_type_0 = None
    var_0 = module_6.generate_tokens(none_type_0)
    var_0.values()

@pytest.mark.xfail(strict=True)
def test_case_43():
    numpydoc_parser_0 = module_1.NumpydocParser()
    assert f'{type(numpydoc_parser_0).__module__}.{type(numpydoc_parser_0).__qualname__}' == 'docstring_parser.numpydoc.NumpydocParser'
    assert f'{type(numpydoc_parser_0.sections).__module__}.{type(numpydoc_parser_0.sections).__qualname__}' == 'builtins.dict'
    assert len(numpydoc_parser_0.sections) == 31
    assert f'{type(numpydoc_parser_0.titles_re).__module__}.{type(numpydoc_parser_0.titles_re).__qualname__}' == 're.Pattern'
    numpydoc_parser_0.parse(numpydoc_parser_0)

@pytest.mark.xfail(strict=True)
def test_case_44():
    none_type_0 = None
    module_6.open(none_type_0)

@pytest.mark.xfail(strict=True)
def test_case_45():
    str_0 = 'cWElBk8z,KJb9m{'
    str_1 = 'w\rU@hf+!5KAPQ<^'
    sphinx_section_0 = module_1._SphinxSection(str_0, str_1)
    assert f'{type(module_1._SphinxSection.title_pattern).__module__}.{type(module_1._SphinxSection.title_pattern).__qualname__}' == 'builtins.property'
    str_2 = 'I'
    raises_section_0 = module_1.RaisesSection(str_2, str_2)
    module_0.getmro(str_2)

@pytest.mark.xfail(strict=True)
def test_case_46():
    none_type_0 = None
    module_0.formatargspec(none_type_0, none_type_0, formatvarkw=none_type_0)

@pytest.mark.xfail(strict=True)
def test_case_47():
    str_0 = 'XQ?{ O0Ls#A'
    str_1 = '\\s*(.+?)\\s*\\(\\s*(.*[^\\s]+)\\s*\\)'
    raises_section_0 = module_1.RaisesSection(str_1, str_0)
    k_v_section_0 = module_1._KVSection(str_0, str_0)
    examples_section_0 = module_1.ExamplesSection(str_0, str_0)
    var_0 = module_2.get_source_segment(raises_section_0, str_1)
    var_0.__complex__()

@pytest.mark.xfail(strict=True)
def test_case_48():
    str_0 = 'Parser for numpydoc parameter sections.\n\n    E.g. any section that looks like this:\n        arg_name\n            arg_description\n        arg_2 : type, optional\n            descriptions can also span...\n            ... multiple lines\n    '
    str_1 = ',?'
    returns_section_0 = module_1.ReturnsSection(str_0, str_1)
    module_4.fullmatch(str_0, str_0, str_0)

@pytest.mark.xfail(strict=True)
def test_case_49():
    str_0 = 'vYe52+^Bt&#l\ni\x0c'
    module_7.ISNONTERMINAL(str_0)